# [기술 보고서] DQN‑HRL 기반 마켓메이킹 수익화 알고리즘 분석 및 전략 가이드 (초안)

> **목표(한 줄 요약)**  
> 고객 주문(매수/매도)을 최대한 **내부에서 서로 상쇄(넷팅)** 해서 “은행에 내는 비용”을 줄이고,  
> 남는 재고(리스크)는 **필요할 때만** 정리(헤지/청산)하도록 **DQN‑HRL(강화학습+계층형 제어)** 로 자동 운영한다.

---

## 1. 시뮬레이션 성과 요약 (USD 전용)

### 1.1 실험 범위/환경(코드 기준)
- **대상 통화**: USD
- **입력 데이터**
  - 환율 시계열: `환율(KST).xlsx` (컬럼 `USD`, `시간(KST)`)
  - 거래 체결 데이터: `거래데이터(KST).csv` (컬럼 `체결시간`, `통화`, `주문유형`, `수량`, `가격/체결단가` 등)
- **시간 기준**: KST
- **운영/시장 제약(코드에 반영된 단순 모델)**
  - 은행 스프레드 `bank_s`를 시간대별로 다르게 둠  
    - 09~16시: `0.3` (상대적으로 유리)
    - 그 외: `0.6`
  - 02~09시: `is_closed=True` 로 가정(은행 청산 불가 → 포지션 정리 안 함)

### 1.2 이 시뮬레이터가 “무엇을” 측정하나?
이 코드는 크게 손익을 2개로 나눠 봅니다.

1) **거래/청산 손익(PnL)**  
- “어떤 주문(로트)을 언제 청산했는지”에 의해 발생하는 손익

2) **넷팅 수익(netting_profit)**  
- 고객 주문이 서로 반대 방향으로 들어오면서,  
  원래는 은행에서 스프레드(비용)를 내고 처리해야 할 걸 **내부 상쇄**로 처리해서 아낀 비용을 “수익처럼” 잡은 값

> 즉, 목표는 **(A) 넷팅 수익을 크게** + **(B) 재고 리스크를 폭발시키지 않게** 운영하는 것입니다.

### 1.3 DQN‑HRL이 기존 룰 기반과 다른 핵심
- **룰 기반**: “변동성 크면 줄이고 / 주문 많으면 늘리고” 같은 고정 규칙이 많음
- **DQN‑HRL**:  
  - 상위(Manager)가 “오늘/지금은 공격적으로 갈지, 보수적으로 갈지”를 **상태를 보고 선택**  
  - 하위(Worker)는 그 선택을 바탕으로 **TP/시간청산/리스크청산**을 수행

---

## 2. 수익 곡선을 우상향으로 만드는 3가지 동력

> 아래 3개가 동시에 돌아가야 누적 수익이 “완만하게, 꾸준히” 올라갑니다.

### 2.1 스프레드/마진 구조(기본 수익 베이스)
- 마켓메이커는 구조적으로 **매수/매도 호가 차이(스프레드)** 또는 **플랫폼 마크업**에서 수익 기반이 생깁니다.
- 본 코드에서는 “고객 가격과 은행 청산 가격의 차이”를 `expected`로 단순 계산해서,
  - 이 값이 충분히 커지면(Tier1) 익절
  - 시간이 지나면(Tier2) 정리
  - 재고가 한도를 넘으면(Tier3) 강제 정리
  로 수익을 실현합니다.

### 2.2 내부 넷팅(Netting) 수익(진짜 중요한 고정 엔진)
코드에서 넷팅은 이런 상황에서 발생합니다.

- 현재 재고 `inventory`가 **+**(USD를 많이 들고 있음)인데,
- 새로운 고객 주문이 반대로 들어와 `cu_qty`가 **-** 로 들어오면  
  → 내부에서 서로 상쇄될 수 있음

그때,
- `matched = min(abs(inventory), abs(cu_qty))`
- 넷팅 수익(절감된 비용)을
  - `matched * bank_s * 2` 로 잡습니다.  
    (단, 은행 닫혔으면 0)

**왜 `*2`인가? (아주 쉽게)**  
- 은행을 통하면 매수/매도 양쪽에서 스프레드 비용이 발생하는 걸 단순화해서 “왕복 비용”처럼 잡은 모델입니다.  
- 즉, 내부에서 상쇄하면 그만큼 비용이 줄었다고 보는 겁니다.

> 결론: 고객 주문이 많이 교차(매수/매도 섞임)할수록 넷팅 수익이 안정적으로 쌓입니다.

### 2.3 지능형 리스크 관리: “언제 공격/언제 수비”를 DQN이 고름
리스크 관리는 한 문장으로:
- **재고가 쌓일 때**: 급하게 정리하면 비용(스프레드)이 크고, 기다리면 넷팅 기회가 생김  
- **너무 오래/너무 많이 쌓이면**: 환율 변동으로 손실 폭발 가능

DQN‑HRL은 이 균형점을 학습으로 찾아가게 설계되어 있습니다.
- 변동성/주문간격/재고상태를 보고
- “지금은 기다리는 전략 vs 지금은 빨리 정리하는 전략”을 선택합니다.

---

## 3. 전략: DQN‑HRL 기반 네팅 극대화 로직

> 첨부 템플릿의 “ACD 기반 dynamic_limit” 자리에,  
> 여기서는 “**DQN‑HRL이 고르는 행동(action)이 곧 동적 한도/정리 기준**”이 됩니다.

### 3.1 로직 설명 및 구현

#### (1) HRL 구조: Manager(상위) / Worker(하위)

- **Manager (DQN)**
  - 일정 간격(`manager_interval = 100`)마다 한 번씩만 큰 결정을 내립니다.
  - 행동(action) 하나를 고르면, 그 행동이 Worker에게 “운영 파라미터 세트”로 내려갑니다.

- **Worker (규칙 기반 실행)**
  - Manager가 내려준 파라미터로 실제 주문을 쌓고, 청산을 실행합니다.
  - 청산은 3단계(Tier1~Tier3)로 수행합니다.

이 구조가 좋은 이유(아주 쉽게):
- 매 거래마다 DQN이 미세 결정을 하면 학습이 흔들리고 느립니다.
- 대신 “큰 정책(공격/수비)”만 DQN이 정하고,
- 실제 실행은 규칙(TP/타임아웃/리스크컷)이 안정적으로 처리합니다.

---

#### (2) DQN의 “행동(action)”이 의미하는 것: (S_i, T_w, Limit)

코드의 액션맵은 다음과 같습니다.

- `S_i`: 익절 기준(얼마 이익 나면 정리할지)
- `T_w`: 기다릴 시간(분). 이 시간 넘으면 시간 청산
- `Limit`: 재고 한도. 넘으면 리스크 청산

예시(액션 하나):
- `(S_i=0.15, T_w=240, Limit=200000)`  
  → “중간 익절, 4시간은 기다려보고, 재고는 20만까지 허용”

즉, DQN이 하는 일은 사실상:
- **익절을 촘촘하게 할지(작은 이익도 빨리 먹기)**
- **얼마나 오래 기다릴지(넷팅 기회 확보)**
- **재고를 얼마나 허용할지(수익 vs 리스크 트레이드오프)**
를 상황에 따라 선택하는 것입니다.

---

#### (3) 상태(state)는 무엇을 보고 판단하나?

코드의 상태는 3차원입니다.

- `vol`: 변동성(환율 수익률 표준편차 롤링)
- `dur`: 다음 주문까지의 기대 시간(ACD 스타일)
- `inv`: 현재 재고가 한도 대비 어느 정도인지

구현:
````python
def get_state(vol, dur, inv, limit):
    return np.array([vol * 1000, dur / 600, inv / limit], dtype=np.float32)
